snapshots["runs the expected postgresql queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Index Only Scan using idx_delayed_jobs_failed on public.delayed_jobs  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
---
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.attempts > 0)
---
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       TIMEZONE('UTC', NOW()) AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, min(subquery.locked_at), timezone('UTC'::text, now())
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.locked_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.locked_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       TIMEZONE('UTC', NOW()) AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, min(subquery.run_at), timezone('UTC'::text, now())
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected postgresql queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NOT NULL)
---
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NULL)
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.failed_at IS NULL)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone))
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.attempts > 0))
---
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       TIMEZONE('UTC', NOW()) AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, min(subquery.locked_at), timezone('UTC'::text, now())
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.locked_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.locked_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone))
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       TIMEZONE('UTC', NOW()) AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, min(subquery.run_at), timezone('UTC'::text, now())
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)))
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)))
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["runs the expected sqlite3 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_failed
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       CURRENT_TIMESTAMP AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       CURRENT_TIMESTAMP AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected sqlite3 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       CURRENT_TIMESTAMP AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       CURRENT_TIMESTAMP AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["runs the expected mysql2 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Covering index scan on delayed_jobs using idx_delayed_jobs_live  (cost=...)
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` > '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at > TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`attempts` > 0
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.attempts > 0) and (delayed_jobs.failed_at is null))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `failed_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Covering index range scan on delayed_jobs using idx_delayed_jobs_live over (NULL < failed_at)  (cost=...)
---
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       UTC_TIMESTAMP() AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       UTC_TIMESTAMP() AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected mysql2 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` > '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at > TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`attempts` > 0
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.attempts > 0) and (delayed_jobs.failed_at is null))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `failed_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `max_lock_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(locked_at) AS locked_at,
       UTC_TIMESTAMP() AS db_now_utc
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `max_age`:
---------------------------------
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority,
       queue, MIN(run_at) AS run_at,
       UTC_TIMESTAMP() AS db_now_utc
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
SELECT SUM(count) AS sum_count,
       CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an,
       `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP
