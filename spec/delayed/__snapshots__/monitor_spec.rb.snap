snapshots["runs the expected postgresql queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Index Only Scan using idx_delayed_jobs_failed on public.delayed_jobs  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
---
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       TIMEZONE('UTC', STATEMENT_TIMESTAMP()) AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count,
       SUM(CASE WHEN \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN \"delayed_jobs\".\"attempts\" > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), sum(subquery.future_count), sum(subquery.erroring_count), min(subquery.run_at), timezone('UTC'::text, statement_timestamp()), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count, subquery.future_count, subquery.erroring_count, subquery.run_at
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count, subquery.future_count, subquery.erroring_count, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*), sum(CASE WHEN (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone) THEN 1 ELSE 0 END), sum(CASE WHEN (delayed_jobs.attempts > 0) THEN 1 ELSE 0 END), min(CASE WHEN (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone) THEN delayed_jobs.run_at ELSE NULL::timestamp without time zone END)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at, delayed_jobs.attempts
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at, delayed_jobs.attempts
---
-- QUERIES FOR `future_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       TIMEZONE('UTC', STATEMENT_TIMESTAMP()) AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", SUM(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.claimed_count), sum(subquery.claimable_count), min(subquery.locked_at), timezone('UTC'::text, statement_timestamp()), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.claimed_count, subquery.claimable_count, subquery.locked_at
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.claimed_count, subquery.claimable_count, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, sum(CASE WHEN (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone) THEN 1 ELSE 0 END), sum(CASE WHEN ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)) THEN 1 ELSE 0 END), min(CASE WHEN (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone) THEN delayed_jobs.locked_at ELSE NULL::timestamp without time zone END)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected postgresql queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NOT NULL)
---
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       TIMEZONE('UTC', STATEMENT_TIMESTAMP()) AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count,
       SUM(CASE WHEN \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN \"delayed_jobs\".\"attempts\" > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.count), sum(subquery.future_count), sum(subquery.erroring_count), min(subquery.run_at), timezone('UTC'::text, statement_timestamp()), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count, subquery.future_count, subquery.erroring_count, subquery.run_at
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count, subquery.future_count, subquery.erroring_count, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*), sum(CASE WHEN (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone) THEN 1 ELSE 0 END), sum(CASE WHEN (delayed_jobs.attempts > 0) THEN 1 ELSE 0 END), min(CASE WHEN (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone) THEN delayed_jobs.run_at ELSE NULL::timestamp without time zone END)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at, delayed_jobs.attempts
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at, delayed_jobs.attempts
                                Filter: (delayed_jobs.failed_at IS NULL)
---
-- QUERIES FOR `future_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       TIMEZONE('UTC', STATEMENT_TIMESTAMP()) AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", SUM(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

GroupAggregate  (cost=...)
  Output: sum(subquery.claimed_count), sum(subquery.claimable_count), min(subquery.locked_at), timezone('UTC'::text, statement_timestamp()), (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.claimed_count, subquery.claimable_count, subquery.locked_at
        Sort Key: (CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN (subquery.priority < 10) THEN 0 WHEN (subquery.priority < 20) THEN 10 WHEN (subquery.priority < 30) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.claimed_count, subquery.claimable_count, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, sum(CASE WHEN (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone) THEN 1 ELSE 0 END), sum(CASE WHEN ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)) THEN 1 ELSE 0 END), min(CASE WHEN (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone) THEN delayed_jobs.locked_at ELSE NULL::timestamp without time zone END)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.failed_at IS NULL)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["runs the expected sqlite3 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_failed
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       CURRENT_TIMESTAMP AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count,
       SUM(CASE WHEN \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN \"delayed_jobs\".\"attempts\" > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `future_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       CURRENT_TIMESTAMP AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", SUM(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected sqlite3 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       CURRENT_TIMESTAMP AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", COUNT(*) AS count,
       SUM(CASE WHEN \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN \"delayed_jobs\".\"attempts\" > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `future_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       CURRENT_TIMESTAMP AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\", SUM(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"

CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["runs the expected mysql2 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count
  FROM `delayed_jobs`
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Covering index scan on delayed_jobs using idx_delayed_jobs_live  (cost=...)
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       UTC_TIMESTAMP() AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count,
       SUM(CASE WHEN `delayed_jobs`.`run_at` > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN `delayed_jobs`.`attempts` > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is null)  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       UTC_TIMESTAMP() AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, SUM(CASE WHEN `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Covering index range scan on delayed_jobs using idx_delayed_jobs_live over (NULL < failed_at)  (cost=...)
---
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP

snapshots["[legacy index] runs the expected mysql2 queries with the expected plans 1"] = <<-SNAP
-- QUERIES FOR `count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count
  FROM `delayed_jobs`
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `future_count`:
---------------------------------
SELECT SUM(count) AS count,
       SUM(future_count) AS future_count,
       SUM(erroring_count) AS erroring_count,
       MIN(run_at) AS run_at,
       UTC_TIMESTAMP() AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count,
       SUM(CASE WHEN `delayed_jobs`.`run_at` > '2025-11-10 17:20:13' THEN 1 ELSE 0 END) AS future_count,
       SUM(CASE WHEN `delayed_jobs`.`attempts` > 0 THEN 1 ELSE 0 END) AS erroring_count,
       MIN(CASE WHEN `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13' THEN run_at ELSE NULL END) AS run_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is null)  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `locked_count`:
---------------------------------
SELECT SUM(claimed_count) AS claimed_count,
       SUM(claimable_count) AS claimable_count,
       MIN(locked_at) AS locked_at,
       UTC_TIMESTAMP() AS db_now_utc,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, SUM(CASE WHEN `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43' THEN 1 ELSE 0 END) AS claimed_count,
       SUM(CASE WHEN (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43') THEN 1 ELSE 0 END) AS claimable_count,
       MIN(CASE WHEN `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43' THEN locked_at ELSE NULL END) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `erroring_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `failed_count`:
---------------------------------
SELECT SUM(count) AS count,
       CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority,
       queue AS queue
  FROM (SELECT `delayed_jobs`.`priority`, `delayed_jobs`.`queue`, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority < 10 THEN 0 WHEN priority < 20 THEN 10 WHEN priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`

-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
---
-- QUERIES FOR `max_lock_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `max_age`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `working_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `workable_count`:
---------------------------------
-- (no new queries)
-- QUERIES FOR `alert_age_percent`:
---------------------------------
-- (no new queries)
SNAP
