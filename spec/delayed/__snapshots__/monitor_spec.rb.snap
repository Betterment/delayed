snapshots["runs the expected postgresql query for count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Seq Scan on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
SNAP

snapshots["runs the expected postgresql query for future_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for future_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
              Index Cond: (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone)
SNAP

snapshots["runs the expected postgresql query for locked_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for locked_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
              Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["runs the expected postgresql query for erroring_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for erroring_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
              Index Cond: (delayed_jobs.attempts > 0)
SNAP

snapshots["runs the expected postgresql query for failed_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for failed_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Only Scan using idx_delayed_jobs_failed on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
SNAP

snapshots["runs the expected postgresql query for max_lock_age 1"] = <<-SNAP
SELECT CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for max_lock_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, min(locked_at)
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, locked_at
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue, locked_at
              Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["runs the expected postgresql query for max_age 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for max_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, min(run_at)
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, run_at
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue, run_at
              Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
              Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected postgresql query for working_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for working_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
              Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["runs the expected postgresql query for workable_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for workable_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: count(*), (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue
              Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
              Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected postgresql query for alert_age_percent 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected postgresql query plan for alert_age_percent 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, min(run_at)
  Group Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END), queue, run_at
        Sort Key: (CASE WHEN ((delayed_jobs.priority >= 0) AND (delayed_jobs.priority < 10)) THEN 0 WHEN ((delayed_jobs.priority >= 10) AND (delayed_jobs.priority < 20)) THEN 10 WHEN ((delayed_jobs.priority >= 20) AND (delayed_jobs.priority < 30)) THEN 20 WHEN (delayed_jobs.priority >= 30) THEN 30 ELSE NULL::integer END), delayed_jobs.queue
        ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
              Output: CASE WHEN ((priority >= 0) AND (priority < 10)) THEN 0 WHEN ((priority >= 10) AND (priority < 20)) THEN 10 WHEN ((priority >= 20) AND (priority < 30)) THEN 20 WHEN (priority >= 30) THEN 30 ELSE NULL::integer END, queue, run_at
              Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
              Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected sqlite3 query for count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for count 1"] = <<-SNAP
SCAN delayed_jobs
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for future_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for future_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for locked_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for locked_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for erroring_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for erroring_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for failed_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for failed_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_failed
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for max_lock_age 1"] = <<-SNAP
SELECT CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for max_lock_age 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for max_age 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for max_age 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for working_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for working_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for workable_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"delayed_jobs\".\"queue\" AS delayed_jobs_queue
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for workable_count 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for alert_age_percent 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"delayed_jobs\".\"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for alert_age_percent 1"] = <<-SNAP
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected mysql2 query for count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Covering index scan on delayed_jobs using idx_delayed_jobs_live  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for future_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` > '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for future_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at > TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for locked_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for locked_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for erroring_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`attempts` > 0
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for erroring_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: ((delayed_jobs.attempts > 0) and (delayed_jobs.failed_at is null))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for failed_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for failed_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
            -> Covering index range scan on delayed_jobs using idx_delayed_jobs_live over (NULL < failed_at)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for max_lock_age 1"] = <<-SNAP
SELECT CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS priority, queue, MIN(locked_at) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for max_lock_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for max_age 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for max_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for working_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for working_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for workable_count 1"] = <<-SNAP
SELECT COUNT(*) AS count_all, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `delayed_jobs`.`queue` AS delayed_jobs_queue
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for workable_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for alert_age_percent 1"] = <<-SNAP
SELECT (CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END) AS priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `delayed_jobs`.`queue`
SNAP

snapshots["produces the expected mysql2 query plan for alert_age_percent 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP
