snapshots["runs the expected postgresql query for count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Index Only Scan using idx_delayed_jobs_failed on public.delayed_jobs  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NOT NULL)
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NULL)
SNAP

snapshots["runs the expected postgresql query for future_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for future_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone)
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for future_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at > '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.failed_at IS NULL)
SNAP

snapshots["runs the expected postgresql query for locked_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for locked_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for locked_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected postgresql query for erroring_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for erroring_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Only Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.attempts > 0)
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for erroring_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.attempts > 0))
SNAP

snapshots["runs the expected postgresql query for failed_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for failed_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Index Only Scan using idx_delayed_jobs_failed on public.delayed_jobs  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for failed_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Filter: (delayed_jobs.failed_at IS NOT NULL)
SNAP

snapshots["runs the expected postgresql query for max_lock_age 1"] = <<-SNAP
SELECT MIN(locked_at) AS minimum_locked_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for max_lock_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.locked_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.locked_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.locked_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for max_lock_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.locked_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.locked_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.locked_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.locked_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.locked_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected postgresql query for max_age 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for max_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.run_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for max_age 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.run_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)))
SNAP

snapshots["runs the expected postgresql query for working_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for working_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone)
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for working_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND (delayed_jobs.locked_at >= '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["runs the expected postgresql query for workable_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for workable_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for workable_count 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: sum(subquery.count), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.count
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.count
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, count(*)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)))
SNAP

snapshots["runs the expected postgresql query for alert_age_percent 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected postgresql query plan for alert_age_percent 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.run_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using idx_delayed_jobs_live on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone))
SNAP

snapshots["[legacy index] produces the expected postgresql query plan for alert_age_percent 1"] = <<-SNAP
GroupAggregate  (cost=...)
  Output: min(subquery.run_at), (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  Group Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
  ->  Sort  (cost=...)
        Output: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue, subquery.run_at
        Sort Key: (CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END), subquery.queue
        ->  Subquery Scan on subquery  (cost=...)
              Output: CASE WHEN ((subquery.priority >= 0) AND (subquery.priority < 10)) THEN 0 WHEN ((subquery.priority >= 10) AND (subquery.priority < 20)) THEN 10 WHEN ((subquery.priority >= 20) AND (subquery.priority < 30)) THEN 20 WHEN (subquery.priority >= 30) THEN 30 ELSE NULL::integer END, subquery.queue, subquery.run_at
              ->  GroupAggregate  (cost=...)
                    Output: delayed_jobs.priority, delayed_jobs.queue, min(delayed_jobs.run_at)
                    Group Key: delayed_jobs.priority, delayed_jobs.queue
                    ->  Sort  (cost=...)
                          Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                          Sort Key: delayed_jobs.priority, delayed_jobs.queue
                          ->  Index Scan using delayed_jobs_priority on public.delayed_jobs  (cost=...)
                                Output: delayed_jobs.priority, delayed_jobs.queue, delayed_jobs.run_at
                                Index Cond: (delayed_jobs.run_at <= '2025-11-10 17:20:13'::timestamp without time zone)
                                Filter: ((delayed_jobs.failed_at IS NULL) AND ((delayed_jobs.locked_at IS NULL) OR (delayed_jobs.locked_at < '2025-11-10 16:59:43'::timestamp without time zone)))
SNAP

snapshots["runs the expected sqlite3 query for count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_failed
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for future_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" > '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for future_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for future_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for locked_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for locked_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for locked_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for erroring_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"attempts\" > 0
    AND \"delayed_jobs\".\"failed_at\" IS NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for erroring_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for erroring_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for failed_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"failed_at\" IS NOT NULL
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for failed_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_failed
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for failed_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for max_lock_age 1"] = <<-SNAP
SELECT MIN(locked_at) AS minimum_locked_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for max_lock_age 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for max_lock_age 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for max_age 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for max_age 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for max_age 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for working_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE \"delayed_jobs\".\"locked_at\" >= '2025-11-10 16:59:43'
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for working_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for working_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for workable_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for workable_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for workable_count 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected sqlite3 query for alert_age_percent 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, \"queue\" AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM \"delayed_jobs\"
  WHERE (\"delayed_jobs\".\"locked_at\" IS NULL
    OR \"delayed_jobs\".\"locked_at\" < '2025-11-10 16:59:43')
    AND \"delayed_jobs\".\"failed_at\" IS NULL
    AND \"delayed_jobs\".\"run_at\" <= '2025-11-10 17:20:13'
  GROUP BY \"delayed_jobs\".\"priority\", \"delayed_jobs\".\"queue\") subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, \"queue\"
SNAP

snapshots["produces the expected sqlite3 query plan for alert_age_percent 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX idx_delayed_jobs_live
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["[legacy index] produces the expected sqlite3 query plan for alert_age_percent 1"] = <<-SNAP
CO-ROUTINE subquery
SCAN delayed_jobs USING INDEX delayed_jobs_priority
USE TEMP B-TREE FOR GROUP BY
SCAN subquery
USE TEMP B-TREE FOR GROUP BY
SNAP

snapshots["runs the expected mysql2 query for count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Covering index scan on delayed_jobs using idx_delayed_jobs_live  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for future_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` > '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for future_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at > TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for future_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.failed_at is null) and (delayed_jobs.run_at > TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for locked_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for locked_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for locked_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for erroring_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`attempts` > 0
    AND `delayed_jobs`.`failed_at` IS NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for erroring_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.attempts > 0) and (delayed_jobs.failed_at is null))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for erroring_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.attempts > 0) and (delayed_jobs.failed_at is null))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for failed_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`failed_at` IS NOT NULL
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for failed_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Covering index range scan on delayed_jobs using idx_delayed_jobs_live over (NULL < failed_at)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for failed_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (delayed_jobs.failed_at is not null)  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for max_lock_age 1"] = <<-SNAP
SELECT MIN(locked_at) AS minimum_locked_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, MIN(locked_at) AS locked_at
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for max_lock_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for max_lock_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for max_age 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for max_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for max_age 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for working_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE `delayed_jobs`.`locked_at` >= '2025-11-10 16:59:43'
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for working_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for working_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: ((delayed_jobs.locked_at >= TIMESTAMP'2025-11-10 16:59:43') and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for workable_count 1"] = <<-SNAP
SELECT SUM(count) AS sum_count, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, COUNT(*) AS count
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for workable_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for workable_count 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP

snapshots["runs the expected mysql2 query for alert_age_percent 1"] = <<-SNAP
SELECT MIN(run_at) AS minimum_run_at, CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END AS case_when_priority_0_and_priority_10_then_0_when_priority_10_an, `queue` AS queue
  FROM (SELECT priority, queue, MIN(run_at) AS run_at
  FROM `delayed_jobs`
  WHERE (`delayed_jobs`.`locked_at` IS NULL
    OR `delayed_jobs`.`locked_at` < '2025-11-10 16:59:43')
    AND `delayed_jobs`.`failed_at` IS NULL
    AND `delayed_jobs`.`run_at` <= '2025-11-10 17:20:13'
  GROUP BY `delayed_jobs`.`priority`, `delayed_jobs`.`queue`) subquery
  GROUP BY CASE WHEN priority >= 0
    AND priority < 10 THEN 0 WHEN priority >= 10
    AND priority < 20 THEN 10 WHEN priority >= 20
    AND priority < 30 THEN 20 WHEN priority >= 30 THEN 30 END, `queue`
SNAP

snapshots["produces the expected mysql2 query plan for alert_age_percent 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Covering index lookup on delayed_jobs using idx_delayed_jobs_live (failed_at = NULL)  (cost=...)
SNAP

snapshots["[legacy index] produces the expected mysql2 query plan for alert_age_percent 1"] = <<-SNAP
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Table scan on subquery  (cost=...)
            -> Materialize  (cost=...)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Filter: (((delayed_jobs.locked_at is null) or (delayed_jobs.locked_at < TIMESTAMP'2025-11-10 16:59:43')) and (delayed_jobs.failed_at is null) and (delayed_jobs.run_at <= TIMESTAMP'2025-11-10 17:20:13'))  (cost=...)
                            -> Table scan on delayed_jobs  (cost=...)
SNAP
